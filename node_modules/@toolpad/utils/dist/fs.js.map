{"version":3,"sources":["../src/fs.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { Dirent } from 'fs';\nimport * as yaml from 'yaml';\nimport { yamlOverwrite } from 'yaml-diff-patch';\nimport prettier from 'prettier';\nimport { errorFrom } from './errors';\n\n/**\n * Formats a yaml source with `prettier`.\n */\nasync function formatYaml(code: string, filePath: string): Promise<string> {\n  const readConfig = await prettier.resolveConfig(filePath);\n  return prettier.format(code, {\n    ...readConfig,\n    parser: 'yaml',\n  });\n}\n\nexport type Reviver = NonNullable<Parameters<typeof JSON.parse>[1]>;\n\n/**\n * Like `fs.readFile`, but for JSON files specifically. Will throw on malformed JSON.\n */\nexport async function readJsonFile(filePath: string, reviver?: Reviver): Promise<unknown> {\n  const content = await fs.readFile(filePath, { encoding: 'utf-8' });\n  return JSON.parse(content, reviver);\n}\n\nexport async function readMaybeFile(filePath: string): Promise<string | null> {\n  try {\n    return await fs.readFile(filePath, { encoding: 'utf-8' });\n  } catch (rawError) {\n    const error = errorFrom(rawError);\n    if (error.code === 'ENOENT' || error.code === 'EISDIR') {\n      return null;\n    }\n    throw error;\n  }\n}\n\nexport async function readMaybeDir(dirPath: string): Promise<Dirent[]> {\n  try {\n    return await fs.readdir(dirPath, { withFileTypes: true });\n  } catch (rawError: unknown) {\n    const error = errorFrom(rawError);\n    if (error.code === 'ENOENT' || error.code === 'ENOTDIR') {\n      return [];\n    }\n    throw error;\n  }\n}\n\nexport type WriteFileOptions = Parameters<typeof fs.writeFile>[2];\n\nexport async function writeFileRecursive(\n  filePath: string,\n  content: string | Buffer,\n  options?: WriteFileOptions,\n): Promise<void> {\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\n  await fs.writeFile(filePath, content, options);\n}\n\nexport interface UpdateYamlOptions {\n  schemaUrl?: string;\n}\n\nexport async function updateYamlFile(\n  filePath: string,\n  content: object,\n  options?: UpdateYamlOptions,\n) {\n  const oldContent = await readMaybeFile(filePath);\n\n  let newContent = oldContent ? yamlOverwrite(oldContent, content) : yaml.stringify(content);\n\n  if (options?.schemaUrl) {\n    const yamlDoc = yaml.parseDocument(newContent);\n    yamlDoc.commentBefore = ` yaml-language-server: $schema=${options.schemaUrl}`;\n    newContent = yamlDoc.toString();\n  }\n\n  newContent = await formatYaml(newContent, filePath);\n  if (newContent !== oldContent) {\n    await writeFileRecursive(filePath, newContent);\n  }\n}\n\nexport async function fileExists(filepath: string): Promise<boolean> {\n  try {\n    const stat = await fs.stat(filepath);\n    return stat.isFile();\n  } catch (err) {\n    if (errorFrom(err).code === 'ENOENT') {\n      return false;\n    }\n    throw err;\n  }\n}\n\nexport async function folderExists(folderpath: string): Promise<boolean> {\n  try {\n    const stat = await fs.stat(folderpath);\n    return stat.isDirectory();\n  } catch (err) {\n    if (errorFrom(err).code === 'ENOENT') {\n      return false;\n    }\n    throw err;\n  }\n}\n\nexport async function fileReplace(\n  filePath: string,\n  searchValue: string | RegExp,\n  replaceValue: string,\n): Promise<void> {\n  const queriesFileContent = await fs.readFile(filePath, { encoding: 'utf-8' });\n  const updatedFileContent = queriesFileContent.replace(searchValue, () => replaceValue);\n  await fs.writeFile(filePath, updatedFileContent);\n}\n\nexport async function fileReplaceAll(\n  filePath: string,\n  searchValue: string | RegExp,\n  replaceValue: string,\n) {\n  const queriesFileContent = await fs.readFile(filePath, { encoding: 'utf-8' });\n  const updatedFileContent = queriesFileContent.replaceAll(searchValue, () => replaceValue);\n  await fs.writeFile(filePath, updatedFileContent);\n}\n"],"mappings":";;;;;;;AAAA,YAAY,QAAQ;AACpB,YAAY,UAAU;AAEtB,YAAY,UAAU;AACtB,SAAS,qBAAqB;AAC9B,OAAO,cAAc;AAMrB,eAAe,WAAW,MAAc,UAAmC;AACzE,QAAM,aAAa,MAAM,SAAS,cAAc,QAAQ;AACxD,SAAO,SAAS,OAAO,MAAM;AAAA,IAC3B,GAAG;AAAA,IACH,QAAQ;AAAA,EACV,CAAC;AACH;AAOA,eAAsB,aAAa,UAAkB,SAAqC;AACxF,QAAM,UAAU,MAAS,YAAS,UAAU,EAAE,UAAU,QAAQ,CAAC;AACjE,SAAO,KAAK,MAAM,SAAS,OAAO;AACpC;AAEA,eAAsB,cAAc,UAA0C;AAC5E,MAAI;AACF,WAAO,MAAS,YAAS,UAAU,EAAE,UAAU,QAAQ,CAAC;AAAA,EAC1D,SAAS,UAAU;AACjB,UAAM,QAAQ,UAAU,QAAQ;AAChC,QAAI,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU;AACtD,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,aAAa,SAAoC;AACrE,MAAI;AACF,WAAO,MAAS,WAAQ,SAAS,EAAE,eAAe,KAAK,CAAC;AAAA,EAC1D,SAAS,UAAmB;AAC1B,UAAM,QAAQ,UAAU,QAAQ;AAChC,QAAI,MAAM,SAAS,YAAY,MAAM,SAAS,WAAW;AACvD,aAAO,CAAC;AAAA,IACV;AACA,UAAM;AAAA,EACR;AACF;AAIA,eAAsB,mBACpB,UACA,SACA,SACe;AACf,QAAS,SAAW,aAAQ,QAAQ,GAAG,EAAE,WAAW,KAAK,CAAC;AAC1D,QAAS,aAAU,UAAU,SAAS,OAAO;AAC/C;AAMA,eAAsB,eACpB,UACA,SACA,SACA;AACA,QAAM,aAAa,MAAM,cAAc,QAAQ;AAE/C,MAAI,aAAa,aAAa,cAAc,YAAY,OAAO,IAAS,eAAU,OAAO;AAEzF,MAAI,SAAS,WAAW;AACtB,UAAM,UAAe,mBAAc,UAAU;AAC7C,YAAQ,gBAAgB,kCAAkC,QAAQ,SAAS;AAC3E,iBAAa,QAAQ,SAAS;AAAA,EAChC;AAEA,eAAa,MAAM,WAAW,YAAY,QAAQ;AAClD,MAAI,eAAe,YAAY;AAC7B,UAAM,mBAAmB,UAAU,UAAU;AAAA,EAC/C;AACF;AAEA,eAAsB,WAAW,UAAoC;AACnE,MAAI;AACF,UAAMA,QAAO,MAAS,QAAK,QAAQ;AACnC,WAAOA,MAAK,OAAO;AAAA,EACrB,SAAS,KAAK;AACZ,QAAI,UAAU,GAAG,EAAE,SAAS,UAAU;AACpC,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,aAAa,YAAsC;AACvE,MAAI;AACF,UAAMA,QAAO,MAAS,QAAK,UAAU;AACrC,WAAOA,MAAK,YAAY;AAAA,EAC1B,SAAS,KAAK;AACZ,QAAI,UAAU,GAAG,EAAE,SAAS,UAAU;AACpC,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,YACpB,UACA,aACA,cACe;AACf,QAAM,qBAAqB,MAAS,YAAS,UAAU,EAAE,UAAU,QAAQ,CAAC;AAC5E,QAAM,qBAAqB,mBAAmB,QAAQ,aAAa,MAAM,YAAY;AACrF,QAAS,aAAU,UAAU,kBAAkB;AACjD;AAEA,eAAsB,eACpB,UACA,aACA,cACA;AACA,QAAM,qBAAqB,MAAS,YAAS,UAAU,EAAE,UAAU,QAAQ,CAAC;AAC5E,QAAM,qBAAqB,mBAAmB,WAAW,aAAa,MAAM,YAAY;AACxF,QAAS,aAAU,UAAU,kBAAkB;AACjD;","names":["stat"]}