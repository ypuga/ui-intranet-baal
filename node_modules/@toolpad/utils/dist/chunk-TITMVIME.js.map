{"version":3,"sources":["../src/collections.ts"],"sourcesContent":["export function asArray<T>(maybeArray: T | T[]): T[] {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\ntype PropertiesOf<P> = Extract<keyof P, string>;\n\ntype Require<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\ntype Ensure<U, K extends PropertyKey> = K extends keyof U ? Require<U, K> : U & Record<K, unknown>;\n\n/**\n * Type aware version of Object.protoype.hasOwnProperty.\n * See https://fettblog.eu/typescript-hasownproperty/\n */\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\n  obj: X,\n  prop: Y,\n): obj is Ensure<X, Y> {\n  return obj.hasOwnProperty(prop);\n}\n\n/**\n * Maps `obj` to a new object. The `mapper` function receives an entry array of key and value and\n * is allowed to manipulate both. It can also return `null` to omit a property from the result.\n */\nexport function mapProperties<P, L extends PropertyKey, U>(\n  obj: P,\n  mapper: <K extends PropertiesOf<P>>(old: [K, P[K]]) => [L, U] | null,\n): Record<L, U>;\nexport function mapProperties<U, V>(\n  obj: Record<string, U>,\n  mapper: (old: [string, U]) => [string, V] | null,\n): Record<string, V> {\n  return Object.fromEntries(\n    Object.entries(obj).flatMap((entry) => {\n      const mapped = mapper(entry);\n      return mapped ? [mapped] : [];\n    }),\n  );\n}\n\n/**\n * Maps an objects' property keys. The result is a new object with the mapped keys, but the same values.\n */\nexport function mapKeys<U>(\n  obj: Record<string, U>,\n  mapper: (old: string) => string,\n): Record<string, U> {\n  return mapProperties(obj, ([key, value]) => [mapper(key), value]);\n}\n\n/**\n * Maps an objects' property values. The result is a new object with the same keys, but mapped values.\n */\nexport function mapValues<P, V>(\n  obj: P,\n  mapper: (old: P[PropertiesOf<P>], key: PropertiesOf<P>) => V,\n): Record<PropertiesOf<P>, V> {\n  return mapProperties(obj, ([key, value]) => [key, mapper(value, key)]);\n}\n/**\n * Filters an objects' property values. Similar to `array.filter` but for objects. The result is a new\n * object with all the properties removed for which `filter` returned `false`.\n */\nexport function filterValues<K extends PropertyKey, P, Q extends P>(\n  obj: Record<K, P>,\n  filter: (old: P) => old is Q,\n): Record<K, Q>;\nexport function filterValues<P>(obj: P, filter: (old: P[keyof P]) => boolean): Partial<P>;\nexport function filterValues<U>(\n  obj: Record<string, U>,\n  filter: (old: U) => boolean,\n): Record<string, U>;\nexport function filterValues<U>(\n  obj: Record<string, U>,\n  filter: (old: U) => boolean,\n): Record<string, U> {\n  return mapProperties(obj, ([key, value]) => (filter(value) ? [key, value] : null));\n}\n\n/**\n * Filters an objects' property keys. Similar to `array.filter` but for objects. The result is a new\n * object with all the properties removed for which `filter` returned `false`.\n */\nexport function filterKeys<P>(obj: P, filter: (old: keyof P) => boolean): Partial<P>;\nexport function filterKeys<U>(\n  obj: Record<string, U>,\n  filter: (old: string) => boolean,\n): Record<string, U>;\nexport function filterKeys<U>(\n  obj: Record<string, U>,\n  filter: (old: string) => boolean,\n): Record<string, U> {\n  return mapProperties(obj, ([key, value]) => (filter(key) ? [key, value] : null));\n}\n\n/**\n * Compares the properties of two objects. Returns `true` if all properties are strictly equal, `false`\n * otherwise.\n * Pass a subset of properties to only compare those.\n */\nexport function equalProperties<P extends object>(obj1: P, obj2: P, subset?: (keyof P)[]): boolean {\n  const keysToCheck = new Set(\n    subset ?? ([...Object.keys(obj1), ...Object.keys(obj2)] as (keyof P)[]),\n  );\n  return Array.from(keysToCheck).every((key) => Object.is(obj1[key], obj2[key]));\n}\n"],"mappings":";AAAO,SAAS,QAAW,YAA0B;AACnD,SAAO,MAAM,QAAQ,UAAU,IAAI,aAAa,CAAC,UAAU;AAC7D;AAYO,SAAS,eACd,KACA,MACqB;AACrB,SAAO,IAAI,eAAe,IAAI;AAChC;AAUO,SAAS,cACd,KACA,QACmB;AACnB,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,GAAG,EAAE,QAAQ,CAAC,UAAU;AACrC,YAAM,SAAS,OAAO,KAAK;AAC3B,aAAO,SAAS,CAAC,MAAM,IAAI,CAAC;AAAA,IAC9B,CAAC;AAAA,EACH;AACF;AAKO,SAAS,QACd,KACA,QACmB;AACnB,SAAO,cAAc,KAAK,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,OAAO,GAAG,GAAG,KAAK,CAAC;AAClE;AAKO,SAAS,UACd,KACA,QAC4B;AAC5B,SAAO,cAAc,KAAK,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,OAAO,OAAO,GAAG,CAAC,CAAC;AACvE;AAcO,SAAS,aACd,KACA,QACmB;AACnB,SAAO,cAAc,KAAK,CAAC,CAAC,KAAK,KAAK,MAAO,OAAO,KAAK,IAAI,CAAC,KAAK,KAAK,IAAI,IAAK;AACnF;AAWO,SAAS,WACd,KACA,QACmB;AACnB,SAAO,cAAc,KAAK,CAAC,CAAC,KAAK,KAAK,MAAO,OAAO,GAAG,IAAI,CAAC,KAAK,KAAK,IAAI,IAAK;AACjF;AAOO,SAAS,gBAAkC,MAAS,MAAS,QAA+B;AACjG,QAAM,cAAc,IAAI;AAAA,IACtB,UAAW,CAAC,GAAG,OAAO,KAAK,IAAI,GAAG,GAAG,OAAO,KAAK,IAAI,CAAC;AAAA,EACxD;AACA,SAAO,MAAM,KAAK,WAAW,EAAE,MAAM,CAAC,QAAQ,OAAO,GAAG,KAAK,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC;AAC/E;","names":[]}