{"version":3,"sources":["../src/types.ts"],"sourcesContent":["declare const brand: unique symbol;\n\nexport type WithControlledProp<\n  V,\n  K extends string = 'value',\n  O extends string = K extends 'value' ? 'onChange' : `on${Capitalize<K>}Change`,\n> = Record<K, V> & Record<O, (newValue: V) => void>;\n\nexport type ExactEntriesOf<P> = Exclude<{ [K in keyof P]: [K, P[K]] }[keyof P], undefined>[];\n\n/**\n * The inverse of Awaited.\n */\nexport type Awaitable<T> = T | Promise<T> | PromiseLike<T>;\n\n/**\n * @example\n * type T0 = Join<[1, 2, 3, 4], '.'>;  // '1.2.3.4'\n * type T1 = Join<['foo', 'bar', 'baz'], '-'>;  // 'foo-bar-baz'\n * type T2 = Join<[], '.'>;  // ''\n */\nexport type Join<T extends unknown[], D extends string> = T extends []\n  ? ''\n  : T extends [string | number | boolean | bigint]\n    ? `${T[0]}`\n    : T extends [string | number | boolean | bigint, ...infer U]\n      ? `${T[0]}${D}${Join<U, D>}`\n      : string;\n\n/**\n * @example\n * type T0 = Split<'foo', '.'>;  // ['foo']\n * type T1 = Split<'foo.bar.baz', '.'>;  // ['foo', 'bar', 'baz']\n * type T2 = Split<'foo.bar', ''>;  // ['f', 'o', 'o', '.', 'b', 'a', 'r']\n */\nexport type Split<S extends string, D extends string> = string extends S\n  ? string[]\n  : S extends ''\n    ? []\n    : S extends `${infer T}${D}${infer U}`\n      ? [T, ...Split<U, D>]\n      : [S];\n\n/**\n * @example\n * type T0 = CapitalizeAll<['foo', 'bar']>;  // ['Foo', 'Bar']\n * type T1 = CapitalizeAll<[]>;  // []\n */\nexport type CapitalizeAll<T extends string[]> = T extends []\n  ? []\n  : T extends [string, ...infer U]\n    ? U extends string[]\n      ? [Capitalize<T[0]>, ...CapitalizeAll<U>]\n      : never\n    : never;\n\n/**\n * @example\n * type T0 = CapitalizeAll<['foo', 'bar', 'baz']>;  // ['foo', 'Bar', 'Baz']\n * type T1 = CapitalizeAll<['foo']>;  // ['foo']\n * type T2 = CapitalizeAll<[]>;  // []\n */\nexport type CapitalizeTail<T extends string[]> = T extends []\n  ? []\n  : T extends [string, ...infer U]\n    ? U extends string[]\n      ? [T[0], ...CapitalizeAll<U>]\n      : never\n    : never;\n\n/**\n * sString template type that converts snake-case to camel-case\n * @example\n * type T0 = SnakeToCamel<'foo-bar-baz'>;  // 'fooBarBaz'\n * type T1 = CapitalizeAll<'foo'>;  // 'foo'\n * type T2 = CapitalizeAll<''>;  // ''\n */\nexport type SnakeToCamel<T extends string> = Join<CapitalizeTail<Split<T, '-'>>, ''>;\n\n/**\n * The inverso of NonNullable\n */\nexport type Maybe<T> = T | undefined | null;\n\nexport type ValueOf<T> = T[keyof T];\n\nexport interface Brand<B> {\n  readonly [brand]: B;\n}\n\n// https://stackoverflow.com/a/56749647\nexport type Branded<A, B> = A & Brand<B>;\n\n// See https://github.com/microsoft/vscode/issues/94679#issuecomment-755194161\nexport type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;\nexport type ExpandNested<T> = T extends infer O ? { [K in keyof O]: Expand<O[K]> } : never;\n\nexport {};\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}